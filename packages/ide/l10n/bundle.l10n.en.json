{
  "elf": {
    "stats": {
      "title": "Statistics",
      "description": "<p>This screen offers a high-level summary of the ELF file's structure and contents.</p><h3 style='margin-bottom: 5px;'><strong>File Overview</strong></h3>Displays the basic properties of the ELF file.<ul><li><strong>Format</strong>: ELF 32-bit or 64-bit.</li><li><strong>Data Encoding</strong>: Indicates the endianness (little or big endian).</li><li><strong>File Type</strong>: Executable, relocatable, shared object, or core file.</li><li><strong>Architecture</strong>: Target architecture, e.g., ARM, x86.</li><li><strong>ABI Version</strong>: Application Binary Interface version.</li><li><strong>Debug Info</strong>: Whether the file contains debugging information.</li><li><strong>Stripping</strong>: Whether the file has been stripped of symbol information.</li></ul><h3 style='margin-bottom: 5px;'><strong>Main Section Sizes</strong></h3>Chart showing the sizes of the main sections of the ELF file:<ul><li><strong><span style='color: var(--vscode-charts-orange);'>text</span></strong>: Executable code.</li><li><strong><span style='color: var(--vscode-charts-blue);'>data</span></strong>: Initialized global and static variables.</li><li><strong><span style='color: var(--vscode-charts-green);'>bss</span></strong>: Uninitialized global and static variables (which are initialized to zero).</li></ul><p><i>Note: ELF sections are grouped into 'Main Sections.' You will find small circles with the color corresponding to the 'Main Section' next to the names of specific ELF sections. </br>For example, the main section 'text' may contain ELF sections like <span style='color: #d28716;'>&#9679;</span>.text, <span style='color: #d28716;'>&#9679;</span>.init, <span style='color: #d28716;'>&#9679;</span>.plt, etc., all sharing the same circle color.</i></p><h3 style='margin-bottom: 5px;'><strong>Symbol Types</strong></h3>Categorizes functions and variables based on their binding. <br>Global and weak symbols are accessible outside of their defining component, while local symbols remain hidden. Additionally, global and weak symbols can be preempted, meaning they can be overridden by definitions with the same name in another component.<h3 style='margin-bottom: 5px;'><strong>Sections</strong></h3>Detailed breakdown of each section within the ELF file:<ul><li><strong>Num</strong>: Section number.</li><li><strong>Name</strong>: Name of the section.</li><li><strong>Size</strong>: Size of the section in bytes.</li><li><strong>Functions</strong>: Number of functions within the section.</li><li><strong>Variables</strong>: Number of variables within the section.</li></ul><h3 style='margin-bottom: 5px;'><strong>Largest Symbols</strong></h3>Lists the largest symbols in the ELF file, including:<ul><li><strong>Name</strong>: Name of the symbol.</li><li><strong>Section</strong>: Section where the symbol is located.</li><li><strong>Size</strong>: Size of the symbol in bytes.</li></ul>",
      "chart": {
        "title": "Main section sizes",
        "tooltips": {
          "title": "Main section sizes",
          "description": "The <code>text</code> section contains the executable code of the program.<br />It is typically read-only and may include instructions, read-only data, and some constant values and its size reflects the amount of memory allocated for storing the executable instructions.<br /><br />The <code>data</code> section holds initialized data that the program uses, including global and static variables that have been assigned a value before the program starts.<br />It is readable and writable and contains variables that need to retain their values throughout the execution of the program.<br />Its size indicates the amount of memory needed to store the initialized variables.<br /><br />The <code>bss</code> section (BSS stands for Block Started by Symbol) contains uninitialized data, which includes global and static variables that are declared but not assigned a value initially.<br />It is also readable and writable. Although it does not hold any actual data initially, its size represents the amount of memory reserved for uninitialized variables."
        }
      },
      "symbolTypes": {
        "title": "Symbol Types",
        "tooltips": {
          "title": "Symbol Types",
          "description": "Categorizes functions and variables based on their binding.</br> </br> Global and weak symbols are accessible outside of their defining component, while local symbols remain hidden.</br> Additionally, global and weak symbols can be preempted, meaning they can be overridden by definitions with the same name in another component.</br> </br> <i>Use the buttons (all, text, data, bss) to filter symbols by main section type.</i>"
        }
      },
      "sections": {
        "title": "Sections",
        "tooltips": {
          "title": "Sections",
          "description": "Breakdown of each section within the ELF file.<br /><ul><li> <strong>Num:</strong> The section number.</li> <li><strong>Name:</strong> The name of the section. </li> <li><strong>Size:</strong> The size of the section in bytes.</li> <li> <strong>Functions:</strong> The number of functions within the section.</li> <li> <strong>Variables:</strong> The number of variables within the section.</li></ul>"
        }
      },
      "topSymbols": {
        "title": "Largest Symbols",
        "tooltips": {
          "title": "Largest Symbols",
          "description": "Displays the largest symbols within the ELF file, categorized by their section type.<br /><ul><li><strong>Name:</strong> The name of the symbol.</li><li><strong>Section:</strong> The section where the symbol is located (e.g., text, noinit).</li><li><strong>Size:</strong> The size of the symbol in bytes.</li></ul><br /><br /><i>Use the buttons (all, text, data, bss) to filter symbols by main section type.</i>"
        }
      }
    },
    "metadata": {
      "title": "Metadata",
      "description": "<p>This screen displays detailed information about the ELF file, including its size distribution, header, attributes and inferred characteristics.</p><h3 style='margin-bottom: 5px;'><strong>Main Section Sizes</strong></h3>Chart showing the sizes of the main sections of the ELF file:<ul><li><strong><span style='color: var(--vscode-charts-orange);'>text</span></strong>: Executable code.</li><li><strong><span style='color: var(--vscode-charts-blue);'>data</span></strong>: Initialized global and static variables.</li><li><strong><span style='color: var(--vscode-charts-green);'>bss</span></strong>: Uninitialized global and static variables (which are initialized to zero).</li></ul><p><i>Note: ELF sections are grouped into 'Main Sections.' You will find small circles with the color corresponding to the 'Main Section' next to the names of specific ELF sections. </br>For example, the main section 'text' may contain ELF sections like <span style='color: var(--vscode-charts-orange);'>&#9679;</span>.text, <span style='color: var(--vscode-charts-orange);'>&#9679;</span>.init, <span style='color: var(--vscode-charts-orange);'>&#9679;</span>.plt, etc., all sharing the same circle color.</i></p><h3 style='margin-bottom: 5px;'><strong>Header Info</strong></h3>The ELF file header contains metadata about the ELF file, including its type, architecture, entry point, program headers, and section headers.<br>This information is essential for the operating system to correctly load and execute the file.<h3 style='margin-bottom: 5px;'><strong>AEABI Attributes</strong></h3>The AEABI (ARM Embedded Application Binary Interface) attributes in an ELF file provide important metadata about the binary, such as the target architecture, floating-point configuration, and optimization level.<br>These attributes ensure compatibility and optimize performance by conveying specific details about how the binary was built, allowing tools and runtime environments to correctly interpret and execute the code.<h3 style='margin-bottom: 5px;'><strong>Heuristic Information</strong></h3>Indicates the presence of any heuristic information detected in the ELF file related to the Zephyr and MSDK toolchains.<br>It can provide information regarding Flash and RAM sizes, among other available data.",
      "sizes": {
        "title": "Main Section Sizes",
        "tooltips": {
          "title": "Main Section Sizes",
          "description": "The <code>text</code> section contains the executable code of the program.<br />It is typically read-only and may include instructions, read-only data, and some constant values and its size reflects the amount of memory allocated for storing the executable instructions.<br /><br />The <code>data</code> section holds initialized data that the program uses, including global and static variables that have been assigned a value before the program starts.<br />It is readable and writable and contains variables that need to retain their values throughout the execution of the program.<br />Its size indicates the amount of memory needed to store the initialized variables.<br /><br />The <code>bss</code> section (BSS stands for Block Started by Symbol) contains uninitialized data, which includes global and static variables that are declared but not assigned a value initially.<br />It is also readable and writable. Although it does not hold any actual data initially, its size represents the amount of memory reserved for uninitialized variables."
        }
      },
      "header": {
        "title": "Header Info",
        "tooltips": {
          "title": "Header Info",
          "description": "Contains essential metadata that the operating system needs to execute the file.</br>It enables the OS to correctly interpret and run the binary.",
          "list": {
            "Class": {
              "title": "Indicates the file type, either ELF32 or ELF64"
            },
            "Data": {
              "title": "Indicates the endianness of the file, which can be Least Significant Byte (LSB, little-endian) or Most Significant Byte (MSB, big-endian)"
            },
            "Header Version": {
              "title": "Version of the ELF header. Set to 1 for the original and current version of ELF"
            },
            "OS ABI": {
              "title": "Target operating system and ABI"
            },
            "ABI Version": {
              "title": "Further specifies the ABI version. Its interpretation depends on the target ABI.\nLinux kernel (after at least 2.6) has no definition of it, so it is ignored for statically-linked executables"
            },
            "Type": {
              "title": "Type of the file, such as an executable file (EXEC), relocatable file (REL), or shared object file (DYN)"
            },
            "Machine": {
              "title": "Specifies the target architecture, such as ARM, x86, etc."
            },
            "Version": {
              "title": "Version of the ELF file format"
            },
            "Entry point address": {
              "title": "Memory address where the program starts executing"
            },
            "Program headers start": {
              "title": "Byte offset in the file where the program headers start"
            },
            "Section headers start": {
              "title": "Byte offset in the file where the section headers start"
            },
            "Flags": {
              "title": "Processor-specific flags associated with the ELF file"
            },
            "Header size": {
              "title": "Size of the ELF header in bytes"
            },
            "Program headers size": {
              "title": "Size of a program header table entry in bytes"
            },
            "Number of program headers": {
              "title": "Total number of program headers"
            },
            "Section headers size": {
              "title": "Size of a section header table entry in bytes"
            },
            "Number of section headers": {
              "title": "Total number of section headers"
            },
            "Section header string table index": {
              "title": "Index of the section header table entry that contains the section names"
            }
          }
        }
      },
      "armAttributes": {
        "title": "AEABI Attributes",
        "tooltips": {
          "title": "AEABI Attributes",
          "description": "ARM Embedded Application Binary Interface Attributes.</br>Lists specific attributes relevant to ARM architecture.",
          "list": {
            "Tag_CPU_name": {
              "title": "A CPU name is defined by Arm or the architecture licensee responsible for designing the part. It is the official product name, with no extension and no abbreviation"
            },
            "Tag_CPU_arch": {
              "title": "Specifies the architecture of the CPU, indicating the version of the ARM architecture being used, such as ARMv7 or ARMv8"
            },
            "Tag_CPU_arch_profile": {
              "title": "Defines the profile of the CPU architecture, such as Application, Real-time, Microcontroller, or Secure"
            },
            "Tag_THUMB_ISA_use": {
              "title": "Indicates whether the Thumb Instruction Set Architecture (ISA) is used, which is a compact, efficient instruction set for ARM processors"
            },
            "Tag_ABI_PCS_wchar_t": {
              "title": "Specifies the size and alignment of the wchar_t type in the Procedure Call Standard (PCS) for the ABI, which defines how functions receive parameters and return values"
            },
            "Tag_ABI_FP_denormal": {
              "title": "Describes the handling of denormalized floating-point numbers by the ABI, which refers to very small numbers that do not use the standard floating-point format"
            },
            "Tag_ABI_FP_exceptions": {
              "title": "Indicates whether floating-point exceptions are supported and how they are handled by the ABI, affecting the behavior of floating-point operations"
            },
            "Tag_ABI_FP_number_model": {
              "title": "Specifies the floating-point number model used, such as IEEE 754, detailing how floating-point numbers are represented and manipulated"
            },
            "Tag_ABI_align_needed": {
              "title": "Describes the required alignment for data types, indicating whether the ABI mandates specific alignment for efficient memory access and performance"
            },
            "Tag_ABI_enum_size": {
              "title": "Defines the size of enumeration types (enum) in the ABI, specifying how much memory is allocated for enum values"
            },
            "Tag_ABI_optimization_goals": {
              "title": "Indicates the primary optimization goals, such as speed or size, guiding the compiler on which aspects to prioritize during code generation"
            },
            "Tag_CPU_unaligned_access": {
              "title": "Specifies whether the CPU supports unaligned memory access, allowing data to be read from or written to memory locations that are not aligned to their natural boundaries"
            },
            "Tag_DSP_extension": {
              "title": "Indicates the presence and use of DSP (Digital Signal Processing) extensions, providing additional instructions for efficient processing of digital signals and multimedia applications"
            },
            "Tag_CPU_raw_name": {
              "title": "Specifies the raw name of the CPU. An empty value denotes that the raw name is identical to the CPU name"
            },
            "Tag_ARM_ISA_use": {
              "title": "Indicates whether the ARM instruction set is used"
            },
            "Tag_FP_arch": {
              "title": "Specifies the floating-point architecture used"
            },
            "Tag_WMMX_arch": {
              "title": "Specifies the Wireless MMX architecture used"
            },
            "Tag_Advanced_SIMD_arch": {
              "title": "Specifies the Advanced SIMD (NEON) architecture used"
            },
            "Tag_ABI_PCS_R9_use": {
              "title": "Specifies the usage of register R9 in the Procedure Call Standard"
            },
            "Tag_ABI_PCS_RW_data": {
              "title": "Indicates the read/write data in the Procedure Call Standard"
            },
            "Tag_ABI_PCS_RO_data": {
              "title": "Indicates the read-only data in the Procedure Call Standard"
            },
            "Tag_ABI_PCS_GOT_use": {
              "title": "Specifies the usage of Global Offset Table in the Procedure Call Standard"
            },
            "Tag_ABI_FP_rounding": {
              "title": "Specifies the floating-point rounding mode used"
            },
            "Tag_ABI_FP_user_exceptions": {
              "title": "Indicates the support for user-defined floating-point exceptions"
            },
            "Tag_ABI_align_preserved": {
              "title": "Specifies whether alignment is preserved for data types"
            },
            "Tag_ABI_HardFP_use": {
              "title": "Indicates the use of hardware floating-point instructions"
            },
            "Tag_ABI_VFP_args": {
              "title": "Specifies the use of VFP (Vector Floating Point) registers for function arguments"
            },
            "Tag_ABI_WMMX_args": {
              "title": "Specifies the use of WMMX registers for function arguments"
            },
            "Tag_ABI_FP_optimization_goals": {
              "title": "Specifies the optimization goals for floating-point operations"
            },
            "Tag_compatibility": {
              "title": "Indicates compatibility with specific ABI versions or features"
            },
            "Tag_ABI_FP_16bit_format": {
              "title": "Indicates the format used for 16-bit floating-point numbers"
            }
          }
        }
      },
      "heuristicInfo": {
        "title": "Heuristic Information",
        "tooltips": {
          "title": "Heuristic Information",
          "description": "Indicates the presence of any heuristic information detected in the ELF file related to the Zephyr and MSDK toolchains",
          "list": {
            "Firmware Platform": {
              "title": "Inferred Firmware Platform: Zephyr RTOS, MSDK, or unknown"
            },
            "Main stack size": {
              "title": "Size of stack for initialization and main thread"
            },
            "SRAM size": {
              "title": "SRAM Size in KB."
            },
            "ARM SRAM size": {
              "title": "ARM SRAM size in bytes."
            },
            "ARM Flash size": {
              "title": "ARM Flash size in bytes."
            },
            "RISCV SRAM size": {
              "title": "RISCV SRAM size in bytes."
            },
            "RISCV Flash size": {
              "title": "RISCV Flash size in bytes."
            },
            "Heap memory pool size": {
              "title": "Heap memory pool size in bytes"
            },
            "Detected Compiler": {
              "title": "Detected compiler, version, and toolchain information, if available"
            },
            "Flash size": {
              "title": "Flash Size in KB"
            },
            "Flash load size": {
              "title": "Kernel load size. If non-zero, this option specifies the size, in bytes, of the flash area that the Zephyr image will be allowed to occupy. If zero, the image will be able to occupy from the FLASH_LOAD_OFFSET to the end of the device."
            },
            "Stack Size": {
              "title": "Stack size in bytes"
            },
            "Heap Size": {
              "title": "Heap size in bytes."
            }
          }
        }
      }
    },
    "symbols": {
      "title": "Symbol Explorer",
      "description": "<p>This screen allows you to explore and query the symbols in the ELF file using SQL commands.</p><p>The interface works as a SQL database where each attribute is a column in a table named <code>symbols</code>.<br>You can enter SQL queries in the provided text box to filter and retrieve specific data based on your criteria.</p><h3 style='margin-bottom: 5px;'><strong>Symbol table structure for queries</strong></h3><ul><li><strong>num <i>(integer)</i></strong>: The unique number identifying the symbol.</li><li><strong>name <i>(string)</i></strong>: The name of the symbol.</li><li><strong>type <i>(string)</i></strong>: The type of the symbol, indicating what kind of entity it represents.</li><li><strong>address <i>(integer)</i></strong>: The memory address where the symbol is located.</li><li><strong>section <i>(string)</i></strong>: The section of the program in which the symbol is defined.</li><li><strong>size <i>(integer)</i></strong>: The size of the symbol in bytes.</li><li><strong>localstack <i>(integer/optional)</i></strong>: The worst stack usage size for a function (only local stack, not considering functions called).</li><li><strong>stack <i>(integer/optional)</i></strong>: The worst stack usage size for a function (considering functions called).</li><li><strong>bind <i>(string)</i></strong>: The linkage type of the symbol (e.g., local, global).</li><li><strong>visibility <i>(string)</i></strong>: The visibility of the symbol, indicating its accessibility from other modules (e.g., default, hidden).</li><li><strong>path <i>(string/optional)</i></strong>: The source file location where the symbol is defined, useful for tracing the symbol back to its origin in the codebase.</li></ul></br><i>Note: Optional columns will appear only if additional files are present. For more details, please refer to the 'Worst Stack Usage' and 'Path to Source Code' sections.</i></br><i>Note: To obtain detailed information about specific values in certain columns (such as type, bind, and visibility), right-click on a cell to bring up the contextual menu and select the “Help” option.</i><h3 style='margin-bottom: 5px;'><strong>Examples</strong></h3><ul><li>Filter the results by adding conditions:<br><code>SELECT * FROM symbols <strong>WHERE size > 0 ORDER BY size ASC</strong></code></li><li>Filter the results and display only specific columns:<br><code>SELECT <strong>num, name, type, address, size</strong> FROM symbols WHERE bind = 'GLOBAL'</code></li><li>Use ranges on numeric columns:<br><code>SELECT * FROM symbols WHERE address <strong>BETWEEN 0x100004F5 AND 0x100030F0</strong></code></li></ul><br><h3 style='margin-bottom: 5px;'><strong>More Controls</strong></h3><ul><li>Use the search bar at the top to quickly find symbols by their name or address.</li><li>Sort columns by clicking on the column header.</li><li>Filter by a specific value by right-clicking on a cell and choosing 'Filter by...'</li></ul><br><h3 style='margin-bottom: 5px;'><strong>Saved Queries</strong></h3>Save your frequently used SQL queries for quick access.<br>You can save, modify, and run the queries from that panel.<br><br><h3 style='margin-bottom: 5px;'><strong>Worst Stack Usage</strong></h3>When opening an ELF file that is in a folder containing additional files generated by the compiler (.su and .cgraph files), two additional columns will be available: <code>localstack</code> and <code>stack</code>.<br><br>To generate .su and .cgraph files with GCC, compile your code with the following flags: <code>-fstack-usage -fdump-ipa-cgraph -gdwarf-4</code>.<br><br>Examples for Zephyr and MSDK projects:<ul><li>For Zephyr Projects, add the following flags to <code>CMakeLists.txt</code>:<ul><li><code>zephyr_cc_option(-fstack-usage)</code></li><li><code>zephyr_cc_option(-fdump-ipa-cgraph)</code></li><li><code>zephyr_cc_option(-gdwarf-4)</code></li></ul></li><br><li>For MSDK projects, add the following flags to the <code>Makefile</code>:<ul><li><code>PROJ_CFLAGS += -fstack-usage</code></li><li><code>PROJ_CFLAGS += -fdump-ipa-cgraph</code></li><li><code>PROJ_CFLAGS += -gdwarf-4</code></li></ul></li></ul></br><i>Note: The stack column calculation does not account for recursive functions or loops (a function calling itself or a second function that calls the first).</i><br>When this is detected, the following tags will be displayed:<ul><li><strong>R:</strong> Recursive function detected</li><li><strong>SR:</strong> Self-recursive function detected</li><li><strong>G:</strong> Loop in the call graph detected</li></ul><br><h3 style='margin-bottom: 5px;'><strong>Path to Source Code</strong></h3>When the ELF file includes debug information, an additional column, <code>path</code>, will be available.<br>This column shows the source code, including the filename and line where the symbol is defined.<br>If the original source file is present on the local machine, it can be automatically opened by right-clicking on the path cell and selecting 'Go to symbol source code.'",
      "helpModal": {
        "Type": "<code>NOTYPE</code><br />The type of the symbol is unspecified.<br /><br /><code>OBJECT</code><br />The symbol is linked to a data object such as a variable or an array.<br /><br /><code>FUNC</code><br />The symbol is linked to a function or executable code.<br /><br /><code>SECTION</code><br />The symbol is linked to a section. These symbols are primarily used for relocation and usually have local binding (LOCAL).<br /><br /><code>FILE</code><br />The symbol’s name typically indicates the name of the source file related to the object file. A file symbol has local binding (LOCAL), its section index is SHN_ABS, and it comes before other local symbols in the file.<br /><br /><code>COMMON</code><br />The symbol indicates an uninitialized common block.<br /><br /><code>TLS</code><br />The symbol specifies a Thread-Local Storage entity. When defined, it provides the offset assigned to the symbol, not the actual address. Only special thread-local storage relocations can reference these symbols, and these relocations can only refer to symbols of type TLS. Support for thread-local storage is not mandatory.",
        "Localstack": "Maximum amount of stack memory used locally for this symbol in the worst-case scenario (in bytes)",
        "Stack": "Maximum amount of stack memory used by the application in the worst-case scenario (in bytes)",
        "Bind": "<code>LOCAL</code><br />Local symbols are not visible outside the object file containing their definition. Local symbols of the same name may exist in multiple files without interfering with each other.<br /><br /><code>GLOBAL</code><br />Global symbols are visible to all object files being combined. One file's definition of a global symbol will satisfy another file's undefined reference to the same global symbol.<br /><br /><code>WEAK</code><br />Weak symbols resemble global symbols, but their definitions have lower precedence.",
        "Visibility": "<code>DEFAULT</code><br />The visibility of these symbols is determined by their binding type.<ul><li>Global and Weak Symbols: Visible outside their defining component. They can be overridden by symbols of the same name in other components.</li> <li>Local Symbols: Hidden and not accessible outside their defining component.</li><li>Note: Implementations may limit the visibility of global and weak symbols.</li></ul><br /><br /><code>PROTECTED</code><br />These symbols are visible in other components but cannot be overridden. Any reference to them from within their defining component will always use the local definition.<ul><li>Local Binding: Symbols with local binding cannot have protected visibility. If a symbol with protected visibility is used to resolve a reference from another component, it defaults to DEFAULT visibility.</li><li>Note: Protected visibility does not affect symbol resolution for references from outside the containing load module.</li></ul><br /><br /><code>HIDDEN</code><br />These symbols are not visible to other components. They are inherently protected.<ul><li>Address Passing: Objects referenced by hidden symbols can still be accessed if their addresses are passed outside.</li><li>Link-Editor Behavior: Hidden symbols in relocatable objects must be removed or converted to local binding when included in an executable or shared object.</li></ul><br /><br /><code>INTERNAL</code><br />Defined by processor supplements to further restrict hidden symbols. Generic tools treat internal symbols as hidden.<br />Link-Editor Behavior: Internal symbols in relocatable objects must be removed or converted to local binding when included in an executable or shared object.",
        "Path": "Source code including the filename and line where this symbol is defined.<br><br>If the original source file is present on the local machine, it can be automatically opened by right-clicking on the path cell and selecting 'Go to symbol source code.'"
      }
    },
    "files": {
      "title": "Files Explorer",
      "description": "Files and such"
    },
    "memory layout": {
      "title": "Memory Layout",
      "description": "<p>This screen allows you to visually analyze the placement and size of segments, sections and symbols within the memory layout.</p>The memory layout is displayed in three levels:<code>Segments</code> -> <code>Sections</code> -> <code>Symbols</code><h3 style='margin-bottom: 5px;'><strong>Segments</strong></h3>The initial view shows how the ELF segments are distributed in memory.</br></br>This layer includes a visual representation of the segments in memory, along with a table containing extended information for each segment. When you hover the mouse over a segment in the visual representation, the corresponding segment in the table is highlighted, and vice versa.</br></br><i>Note: In the visual representation, overlapping segments are rendered as smaller rectangles to the right of the main segments. Additionally, small segments may be displayed taller than their actual relative size to enhance usability. Refer to the size value for an accurate size value.</i></br></br>Table columns:<ul><li><strong>Id</strong>: The unique identifier for the segment.</li><li><strong>Type</strong>: The type of the segment, indicating its purpose (e.g., loadable, dynamic).</li><li><strong>Address</strong>: The memory address where the segment begins</li><li><strong>Size</strong>: The size of the segment in bytes</li><li><strong>Flags</strong>: Permissions and attributes for the segment (R: read, W: write, X: executable)</li><li><strong>Align</strong>: The alignment requirement of the segment in memory in bytes.</li></ul></br>When a segment is selected, the next level, showing the sections within that selected segment, is displayed.</br></br><h3 style='margin-bottom: 5px;'><strong>Sections in a Segment</strong></h3>The second layer includes a visual representation of the sections within a segment, along with a table containing extended information for each section. Hovering the mouse over a section in the visual representation will highlight the corresponding section in the table, and vice versa.</br></br>Table columns:<ul><li><strong>Num</strong>: The unique number identifying the section.</li><li><strong>Name</strong>: The name of the section.</li><li><strong>Address</strong>: The memory address where the section begins</li><li><strong>Size</strong>: The size of the section in bytes</li><li><strong>Flags</strong>: Permissions and attributes for the section: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), D (mbind), y (purecode), p (processor specific)</li><li><strong>Type</strong>: The type of the section, indicating its contents and purposes</li></ul></br>When a section is selected, the next level, showing the symbols within that selected section, is displayed.</br></br><h3 style='margin-bottom: 5px;'><strong>Symbols in a Section</strong></h3>The third layer contains information about the selected Section, and a table with all the symbols contained in said section.</br>Table columns:<ul><li><strong>Num</strong>: The unique number identifying the symbol.</li><li><strong>Name</strong>: The name of the symbol.</li><li><strong>Address</strong>: The memory address where the symbol is located</li><li><strong>Size</strong>: The size of the symbol in bytes</li><li><strong>Bind</strong>: The linkage type of the symbol (e.g., local, global).</li><li><strong>Visibility</strong>: The visibility of the symbol, indicating its accessibility from other modules (e.g., default, hidden).</li></ul>",
      "helpModal": {
        "1": {
          "Flags": "<code>R (Read)</code>: The segment is readable, allowing the program to read data from this segment.<br /><br /><code>W (Write)</code>: The segment is writable, meaning the program can modify data in this segment<br /><br /><code>X (executable)</code>: The segment is executable, enabling the program to run code stored in this segment."
        },
        "2": {
          "Flags": "<code>W (Write)</code>: The segment is writable, allowing data modification.<br /><br /><code>A (Alloc)</code>: The segment is allocated in memory during execution.<br /><br /><code>X (Execute)</code>: The segment is executable, allowing code execution.<br /><br /><code>M (Merge)</code>: Identical sections can be merged to save space.<br /><br /><code>S (Strings)</code>: The segment contains null-terminated strings.<br /><br /><code>I (Info)</code>: Extra information provided, such as metadata.<br /><br /><code>L (Link Order)</code>: The section follows a specific linking order.<br /><br /><code>O (Extra OS Processing Required)</code>: Requires additional OS-specific processing.<br /><br /><code>G (Group)</code>: The segment is part of a section group.<br /><br /><code>T (TLS)</code>: The segment contains Thread-Local Storage data.<br /><br /><code>C (Compressed)</code>: The segment is compressed.<br /><br /><code>x (Unknown)</code>: The flag is unknown or reserved.<br /><br /><code>o (OS Specific)</code>: The segment is OS-specific.<br /><br /><code>E (Exclude)</code>: Excluded from final executable.<br /><br /><code>D (Mbind)</code>: Memory binding, typically used for NUMA (non-uniform memory access).<br /><br /><code>y (Purecode)</code>: Segment contains only pure code, without data.<br /><br /><code>p (Processor Specific)</code>: The segment has processor-specific attributes.<br /><br />",
          "Type": "<code>NULL</code>: An unused section type, typically represented by a null entry in the section header table.<br /><br /><code>PROGBITS</code>: A section that holds information defined by the program, such as executable code or initialized data.<br /><br /><code>SYMTAB</code>: A symbol table section that contains entries for each symbol, providing information for linking and symbol resolution.<br /><br /><code>STRTAB</code>: A string table section that contains null-terminated strings, often used for symbol names and other identifiers.<br /><br /><code>RELA</code>: A relocation section that includes explicit addends, used for adjusting addresses in the code or data.<br /><br /><code>HASH</code>: A section that contains a hash table for symbol lookup, facilitating faster symbol resolution.<br /><br /><code>DYNAMIC</code>: A section used for dynamic linking, containing information required for dynamic linking and loading.<br /><br /><code>NOTE</code>: A section that holds notes, typically used for metadata or debugging information about the file.<br /><br /><code>NOBITS</code>: A section that occupies no space in the file; its size is represented, but it does not hold any data until the program is loaded.<br /><br /><code>REL</code>: A relocation section that contains relocation entries without explicit addends, used for adjusting addresses in the code or data.<br /><br /><code>SHLIB</code>: A section that is reserved for definitions of shared library information.<br /><br /><code>DYNSYM</code>: A dynamic symbol table section that contains symbols used for dynamic linking.<br /><br /><code>INIT_ARRAY</code>: A section containing pointers to functions that are called before the main function, typically used for initialization.<br /><br /><code>FINI_ARRAY</code>: A section containing pointers to functions that are called after the main function, typically used for cleanup.<br /><br /><code>PREINIT_ARRAY</code>: A section containing pointers to functions that are called before the initialization function, allowing for early setup.<br /><br /><code>GROUP</code>: A section that contains a group of sections, allowing them to be treated as a single entity during linking.<br /><br /><code>SYMTAB_SHNDX</code>: A section that contains indices for entries in the symbol table, used in conjunction with <code>SYMTAB</code>.<br /><br /><code>RELR</code>: A relocation section specifically designed for relative relocations.<br /><br /><code>LOPROC</code>: A section type reserved for processor-specific semantics.<br /><br /><code>HIPROC</code>: A section type reserved for processor-specific semantics at the upper range.<br /><br /><code>LOUSER</code>: A section type reserved for user-defined semantics at the lower range.<br /><br /><code>HIUSER</code>: A section type reserved for user-defined semantics at the upper range.<br /><br /><code>GNU_INCREMENTAL_INPUTS</code>: A section used for incremental linking, containing input files that contribute to the final binary.<br /><br /><code>GNU_INCREMENTAL_SYMTAB</code>: A section that provides an incremental symbol table for linking.<br /><br /><code>GNU_INCREMENTAL_RELOCS</code>: A section that holds relocation entries for incremental linking.<br /><br /><code>GNU_INCREMENTAL_GOT_PLT</code>: A section for the Global Offset Table (GOT) and Procedure Linkage Table (PLT) used in incremental linking.<br /><br /><code>GNU_ATTRIBUTES</code>: A section containing attributes that describe the sections or the file itself.<br /><br /><code>GNU_HASH</code>: A section that contains a hash table for symbol lookup, optimized for use with GNU tools.<br /><br /><code>GNU_LIBLIST</code>: A section that lists shared libraries required by the executable.<br /><br /><code>GNU_verdef</code>: A section that contains version definitions for dynamic linking.<br /><br /><code>GNU_verneed</code>: A section that specifies version needs for dynamic linking.<br /><br /><code>GNU_versym</code>: A section that associates version information with symbols in the dynamic symbol table.<br /><br /><code>ARM_EXIDX</code>: A section used for exception handling information in ARM architectures.<br /><br /><code>ARM_PREEMPTMAP</code>: A section that contains information for preemption in ARM binaries.<br /><br /><code>ARM_ATTRIBUTES</code>: A section that holds attributes specific to ARM binaries.<br /><br /><code>ARM_DEBUGOVERLAY</code>: A section that provides debug information for overlay sections in ARM binaries.<br /><br /><code>ARM_OVERLAYSECTION</code>: A section that describes overlay sections used in ARM binaries.<br /><br /><code>MIPS_REGINFO</code>: A section that contains register information for MIPS architectures.<br /><br /><code>MIPS_OPTIONS</code>: A section that provides options for MIPS binary execution.<br /><br /><code>MIPS_ABIFLAGS</code>: A section that contains ABI flags specific to MIPS architecture.<br /><br />"
        },
        "3": {
          "Bind": "<code>LOCAL</code><br />Local symbols are not visible outside the object file containing their definition. Local symbols of the same name may exist in multiple files without interfering with each other.<br /><br /><code>GLOBAL</code><br />Global symbols are visible to all object files being combined. One file's definition of a global symbol will satisfy another file's undefined reference to the same global symbol.<br /><br /><code>WEAK</code><br />Weak symbols resemble global symbols, but their definitions have lower precedence.",
          "Visibility": "<code>DEFAULT</code><br />The visibility of these symbols is determined by their binding type.<ul><li>Global and Weak Symbols: Visible outside their defining component. They can be overridden by symbols of the same name in other components.</li> <li>Local Symbols: Hidden and not accessible outside their defining component.</li><li>Note: Implementations may limit the visibility of global and weak symbols.</li></ul><br /><br /><code>PROTECTED</code><br />These symbols are visible in other components but cannot be overridden. Any reference to them from within their defining component will always use the local definition.<ul><li>Local Binding: Symbols with local binding cannot have protected visibility. If a symbol with protected visibility is used to resolve a reference from another component, it defaults to DEFAULT visibility.</li><li>Note: Protected visibility does not affect symbol resolution for references from outside the containing load module.</li></ul><br /><br /><code>HIDDEN</code><br />These symbols are not visible to other components. They are inherently protected.<ul><li>Address Passing: Objects referenced by hidden symbols can still be accessed if their addresses are passed outside.</li><li>Link-Editor Behavior: Hidden symbols in relocatable objects must be removed or converted to local binding when included in an executable or shared object.</li></ul><br /><br /><code>INTERNAL</code><br />Defined by processor supplements to further restrict hidden symbols. Generic tools treat internal symbols as hidden.<br />Link-Editor Behavior: Internal symbols in relocatable objects must be removed or converted to local binding when included in an executable or shared object."
        }
      },
      "aboutSectionList": {
        "Section Name": "Identifies each section within the file",
        "Section Type": "Specifies the purpose and content of each section within the file. It defines the kind of data stored in the section, such as code, symbols, relocation information, or metadata. Common section types include executable code, symbol tables, string tables, and relocation entries",
        "Starting Address": "Indicates the memory address where the section will be loaded during program execution",
        "Ending Address": "Represents the memory address where a section concludes, marking the boundary where the section’s content ends in memory during program execution",
        "Size": "This size is measured in bytes and includes all the data or code contained in the section. For sections that do not occupy space in the file but are allocated in memory, such as .bss (uninitialized data), the size indicates how much memory will be reserved when the program is loaded.",
        "Is part of": "ELF Sections are grouped into 'Main sections': 'text' for executable code, 'data' for initialized data, and 'bss' for uninitialized data",
        "Flags": "Describe the attributes and permissions of a section, such as whether the section is writable, executable, or allocated in memory during program execution. These flags help the system manage how the section behaves, including if it contains code, data, or special linking information"
      }
    }
  },
  "cfgtools": {
    "dashboard": {
      "title": "System Planner Configuration Tools dashboard",
      "description": "<p>Get a complete overview of your system configuration with the System Planner Configuration tools dashboard.<ul><li><strong>Navigate to system tools pages</strong>: Use the links to access tools for allocating peripherals, assigning pins, configuring clocks, partitioning memory, and viewing registers. Once your setup is complete, generate code for your project.</li><br /><li><strong>Review existing configurations</strong>: Use the Workspace Projects table to review resource assignments for each core and ensure proper configuration before code generation. If a conflict is detected, an error icon will appear. Click the chevron (>) in any cell to jump to the relevant configuration page and resolve issues.</li><br /><li><strong>Access documentation</strong>: View board-specific documentation links that provide quick access to product information, datasheets, and user guides.</li></ul></p>",
      "help": {
        "title": "System Planner Dashboard Help"
      },
      "helpSection": {
        "title": "Help",
        "cfs-configuration-tools-overview": "CFS configuration tool overview"
      },
      "workspace_projects_table": {
        "table": {
          "title": "Workspace Projects"
        },
        "column": {
          "core": "Core",
          "code-generation": "Code Generation Plugin",
          "assigned-pins": "Assigned Pins",
          "allocated-peripherals": "Allocated Peripherals",
          "memory-partitions": "Memory Partitions"
        }
      },
      "system_config_tools": {
        "title": "System Planner Configuration Tools",
        "allocate-peripherals": "Allocate and Configure Peripherals",
        "assign-pins": "Assign and Configure Pins",
        "configure-clocks": "Configure Clocks",
        "partition-memory": "Allocate and Partition Memory",
        "registers": "View Registers",
        "generate-code": "Generate Code"
      }
    },
    "pinmux": {
      "title": "Pin Config",
      "description": "<p>This screen allows you to configure the pin multiplexing for your project. It also allows you to configure GPIO pins with settings such as drive strength and use pull-up or pull-down resistors to avoid floating inputs.</p><br /><h2>Main canvas overview</h2><p>The main canvas depicts the footprint of your project processor, showing the layout of the pins on the package. Each pin is color-coded according to whether it has a fixed-function, has a signal already assigned, or is available for use.</p><ul>  <li>Pins with multiple signals assigned are shown in <span style='color: var(--vscode-charts-red);'>red</span> to indicate a conflict error.</li>  <li>You can save a project with conflicts, but code generation is blocked until errors are fixed.</li></ul><h2>Assigning signals to pins</h2><p>To assign signals to pins, find the signal you wish to assign in the left-hand side panel. Signals are grouped by the peripheral they belong to. </p><ul>  <li>Expand the peripheral to view signals.</li> <li>Enable available signals using the toggle.</li><li>If a signal can be mapped to multiple pins, select your desired pin.</li>  <li>Conflicts during assignment will be marked with a red cross in the side panel.</li>  <li>You can also navigate around the footprint and click directly on pins to assign signals.</li></ul><h2>Modifying signal configuration</h2><p>Once a signal is assigned to a pin, you can click the icon to the right of the signal's toggle in the side panel to modify its configuration. A separate side panel will open on the right where you can adjust the signal's settings.</p><br /><p><strong>Important:</strong> Before configuring a signal, ensure its peripheral is assigned to a core in the <strong>Peripheral Allocation</strong> screen.</p>",
      "help": {
        "title": "Pin Config Help"
      }
    },
    "config": {
      "title": "Function Config",
      "description": "<p>This screen focuses on allowing you to configure the signals that you have assigned using the <strong>Pin Mux</strong> screen. You can view all the signals you have assigned to pins, and for each one, you can click on it to view the editable configuration options for the signal. These may include:<ul><li>Input vs output mode</li><li>Drive strength</li><li>Pull-up and pull-down resistors</li><li>Power Supply</li><li>Identifiers used when generating code for platforms such as Zephyr</li></ul></p><p>Changes to the configuration values persist automatically. If you wish to reset the values to their default values and discard any changes, click on <strong>Reset to default</strong>.</p>",
      "help": {
        "title": "Function Config Help"
      }
    },
    "clockconfig": {
      "title": "Clock Config",
      "description": "<p>This screen allows you easily configure the clock frequencies that are used by each of the peripherals and cores on the processor. It includes error checking to ensure that the frequencies user are within the constraints of the processor specification. After configuring your clock tree using this screen, you can then generate code that will configure the hardware to the desired configuration.</p><p>The main part of the screen is a visual representation of the clock tree, similar to that which can be found in the processor User Guide. The diagram contains nodes which represent the cores, peripherals, pins, multiplexers and clock scalers present in the processor. The frequencies used at each node are shown within the node, or in the case where a single node is associated with multiple frequencies (for example, a single node represents multiple peripheral instances), the frequencies can be seen by hovering your mouse over the node. Likewise, frequency and other information can be seen by hovering over the lines in the diagrams, which represent clocks. Nodes and clock lines on the diagram are grayed when they are not in use.</p><p>In the left panel, the nodes from the diagram are listed, grouped by the type of the node. These comprise:<ul><li><strong>Core</strong>: One of the cores on the processor.</li><li><strong>Divider</strong>: A frequency step-down scaler node.</li><li><strong>Multiplier</strong>: A frequency step-up scaler node</li><li><strong>Mux</strong>: A multiplexer that selects one of its inputs. In some cases, a mux can also direct a single input to one of its outputs.</li><li><strong>Oscillator</strong>: One of the internal oscillators present in the processor.</li><li><strong>Peripheral</strong>: A peripheral of the processor that is fed by one of the clocks. A peripheral can often be enabled or disabled.</li><li><strong>Pin Input</strong>: A pin that can be attached to an external oscillator. Usually, to use a pin input you will need to assign it using the <strong>Pin Mux</strong> tool first.</li><li><strong>Pin Output</strong>: A pin that can send a clock out externally. Usually, to use a pin output you will need to assign it using the <strong>Pin Mux</strong> tool first.</li></ul></p><p>To configure your clocks, the easiest way is to click on the nodes you want to configure on the diagram, and then use the left-hand panel to modify the settings of that node. After changing a setting, verify using the diagram that the frequencies at each peripheral and core are as desired. Also, look on the diagram to see if any of the nodes are shown in red, indicating an error. By clicking on or hovering over a node you can find out the cause of the error. The cause might be:<ul><li>A frequency out of range: The error will indicate whether the frequency is above or below the limits of operability of the peripheral.</li><li>Unconfigured value: This error usually means that you have not specified the frequency at a pin input. It can also mean that you have not set the pin mux to direct the clock signal to the peripheral.</li></ul>After fixing errors and ensuring you have the desired frequencies at your enabled periphrerals, you can proceed to generate code using the <strong>Generate Code</strong> screen.</p>",
      "help": {
        "title": "Clock Config Help"
      }
    },
    "peripherals": {
      "title": "Peripheral Allocation",
      "description": "<p>The peripheral allocation feature allows you to assign peripherals and GPIO pins to cores. The left panel lists available peripherals, while the main screen displays cores.</p><br /><h2>Assigning a peripheral to a core</h2><ol><li>In the left panel, find the peripheral and click the chevron to expand it.</li><li>Click <strong>Assign (>)</strong> to see available cores.<ul><li>For GPIO peripherals, individual pins can be assigned instead of the entire peripheral. The process remains the same—just select the specific pin instead.</li></ul></li><li>Select a core to manage the peripheral.</li><li>The peripheral appears under the selected core in the main screen.</li></ol><br /><h2>Configuring a peripheral</h2><p>Click the configure icon next to an assigned peripheral or signal. This opens the <strong>Details</strong> section in the right-hand sidebar. From here, you can:</p><ul><li>Click the delete icon to remove the allocation.</li><li>Add a <strong>Description</strong> to give the peripheral or signal a meaningful name.</li><li>View signals used by the peripheral and manage pin assignments.</li><li>Configure the peripheral for its intended use.</li></ul>",
      "help": {
        "title": "Peripheral Allocation Help"
      }
    },
    "memory": {
      "title": "Memory Allocation",
      "description": "<p>The memory allocation feature allows you to partition SoC memory across different cores. The left panel lists available memory banks and existing memory partitions, while the central area displays memory partitions grouped by core.</p><br /><h2><strong>Creating a partition</strong></h2><br /><p>To create a new partition, click <strong>Create Partition</strong> in the left panel and supply the following information:</p><ul><li><strong>Details</strong><ul><li><strong>Memory Type</strong>: The type of memory (e.g., RAM, FLASH).</li><li><strong>Partition Name</strong>: A unique name for the partition.</li></ul></li><br/><li><strong>Assigned Core(s)</strong><ul><li><strong>Core(s)</strong>: Choose one or more cores that require access.</li><li><strong>Access Permissions</strong>: Configure access permissions (e.g., read, read/write) for each assigned core.</li><li><strong>Owner</strong>: If multiple cores are assigned, designate one as the owner. The owner core is responsible for initializing the memory. Other cores may access the memory but do not manage it.</li></ul></li><br/><li><strong>Plugin Options</strong><p>Use these fields to pass additional configuration to the code generation plugin for the selected core. The available options depend on the firmware platform. For example, for a Zephyr-based core, you might enter <code>sram</code> or <code>flash</code> into chosen field to assign a specific role (such as system SRAM or flash storage) to the memory region. Multiple values can be entered as a comma-separated list.</p></li><br /><li><strong>Memory Blocks</strong><ul><li><strong>Base Block</strong>: Select a base memory block. If left blank, this value is auto-determined based on the starting address.</li><li><strong>Starting Address</strong>: Specify a hexadecimal address for the start of the partition. This field updates automatically if a base block is selected.</li><li><strong>Size</strong>: Enter the size of the partition (KB, MB, or bytes).</li></ul></li></ul><h2><strong>Managing existing partitions</strong></h2><br /><p>Created partitions appear under their assigned cores in the central view. Expand the memory panel to view partitions. You can click the configure icon to update partition details, or use the delete icon to remove the partition.</p>",
      "help": {
        "title": "Memory Allocation Help"
      },
      "blocks": {
        "no-blocks-found": "No results to display. Reduce the number of filters applied.",
        "occupied-memory": "in this block",
        "min-alignment": "Minimum Alignment",
        "memory-blocks": "Memory Blocks",
        "available-total": "Available / Total",
        "base": "Base Block",
        "starting-address": "Starting Address",
        "size": "Size"
      },
      "access": {
        "R/W": {
          "title": "Read/Write"
        },
        "R": {
          "title": "Read"
        },
        "R/W/X": {
          "title": "Read/Write/Execute"
        },
        "R/X": {
          "title": "Read/Execute"
        }
      },
      "core": {
        "owner": "Owner"
      },
      "partition": {
        "create": "Create Partition",
        "edit": "Edit Partition",
        "details": "Details",
        "type": "Memory Type",
        "name": "Partition Name",
        "badge": {
          "primary": "Primary",
          "secure": "Secure",
          "non_secure": "Non-secure",
          "external_managed": "Externally-managed"
        },
        "plugin-options": "Plugin Options",
        "missing-assignment": "Please assign to a core to configure plugin options.",
        "num_partitions": {
          "zero": "No memory partitions allocated yet.",
          "one": {
            "label": {
              "title": "Partition"
            }
          },
          "other": {
            "label": {
              "title": "Partitions"
            }
          }
        },
        "partition_type": {
          "volatile": {
            "label": "Volatile"
          },
          "volatile-memory": "Volatile Memory",
          "non-volatile-memory": "Non-Volatile Memory",
          "non-volatile": "Non-Volatile"
        }
      },
      "user-partition": {
        "header": {
          "title": "User Created Partitions"
        },
        "empty": {
          "title": "No user-created partitions yet."
        },
        "core-info": {
          "title": "Info"
        },
        "assigned-cores": {
          "label": "Assigned Core(s)"
        },
        "start-address": {
          "label": "Start Address"
        },
        "end-address": {
          "label": "End Address"
        },
        "range": "Memory Range",
        "block": {
          "header": {
            "title": "Blocks"
          }
        }
      }
    },
    "registers": {
      "title": "Registers",
      "description": "<p>This screen allows you to view information on the registers used by the configuration code. It also highlights registers that are modified due to changes in peripheral or signal configurations. For each register, you can see: <ul><li><strong>Name</strong>: The name of the register.</li><li><strong>Address</strong>: The address of the memory-mapped register.</li><li><strong>Description</strong>: A description of what the register is used for.</li><li><strong>Value</strong>: The value the register will have after execution of the configuration code.</li></ul></p><p>The registers can be sorted on each column, and the filters at the top of the screen allow you to view only those registers that have changed from their default values.</p><p>If you click on a register, you can see information on the fields within the register, including:<ul><li>The name of the bit field.</li><li>The description of the bit field.</li><li>The meaning of the values the bit field can take.</li><li><strong>Bits</strong>: The position of the field within the register.</li><li><strong>Access</strong>: The read-write permissions for the field.</li><li><strong>Value</strong>: The value of the field after completion of the configuration code.</li><li><strong>Reset value</strong>: The value of the field at processor reset.</li></ul></p>",
      "help": {
        "title": "Registers Help"
      },
      "details-section": {
        "name": "Name",
        "bits": "Bits",
        "access": "Access",
        "value": "Value",
        "reset": "Reset",
        "description": "Description"
      }
    },
    "generate": {
      "title": "Generate Code",
      "description": "<p>This screen allows you to generate the configuration code for your project. If your configuration contains any errors, such as pin mux conflicts or clock configuration errors, you must correct these errors before you can generate code.</p></br><h2>Generating Code</h2><p>To generate code, select all the available cores (recommended) and click <strong>Generate</strong>. If your configuration is not saved, you will be prompted to save it before you can continue.</p> </br><p>The generated filenames and locations are chosen so that the code is automatically picked up and built in your project. There is no need to explicitly call the generated functions as the start-up code will automatically do this for you.</p></br><p><strong>Important:</strong> Generated files will overwrite any existing versions.</p>",
      "help": {
        "title": "Generate Code Help"
      },
      "warningModal": {
        "title": "Overwrite existing files",
        "description": "Choosing to continue with your selection will overwrite any existing changes you have made to the generated files.",
        "dismiss": "Don't show this message again."
      }
    }
  },
  "project-wizard": {
    "misc": {
      "cancel": {
        "title": "Cancel"
      },
      "generate": {
        "title": "Generate"
      },
      "available": {
        "title": "available"
      },
      "browse": {
        "title": "Browse"
      },
      "loading": {
        "title": "Loading..."
      },
      "sdkDownloadLink": {
        "title": "Download SDK"
      },
      "setSdkPathLink": {
        "title": "Choose SDK path"
      }
    },

    "errors": {
      "invalidCharacters": {
        "description": "Project name contains invalid characters."
      },
      "emptyString": {
        "description": "Project name cannot be an empty string."
      },
      "noSpacesProject": {
        "description": "Project name cannot contain spaces."
      },
      "noSpacesLocation": {
        "description": "Project location cannot contain spaces."
      },
      "alreadyExists": {
        "description": "Project name already exists."
      },
      "notExists": {
        "description": "Project location does not exist."
      },
      "fileNotExists": {
        "description": "File does not exist."
      },
      "boardNotMatchProc": {
        "description": "The processor and board file don't match. Please correct."
      },
      "socDataUnavailable": {
        "description": "The SoC data is unavailable. Please download and install the CFS SDK, or set the path to the CFS SDK through the CodeFusion Studio extension settings."
      }
    },

    "header": {
      "title": "Create a project",
      "description": "Ensure you have the details of the SoC at hand. Our project wizard guides you through the steps to create your new project."
    },
    "projectName": {
      "title": "Project name",
      "description": "Start typing..."
    },
    "soc": {
      "heading": {
        "name": {
          "title": "Name"
        },
        "description": {
          "title": "Description"
        }
      },
      "label": {
        "title": "Processor"
      },
      "placeholder": {
        "title": "Search SOCs"
      }
    },
    "board": {
      "label": {
        "title": "Board"
      },
      "standard": {
        "name": {
          "title": "Standard"
        },
        "default": {
          "title": "Select EV Kit"
        },
        "procPackage": {
          "title": "Processor Package",
          "description": "Processor package for the selected board."
        }
      },
      "custom": {
        "name": {
          "title": "Custom"
        },
        "header": {
          "description": "Please enter or select your custom board file location."
        },
        "info": {
          "description": "Please ensure the processor you have selected and the custom board file type are compatible."
        },
        "note": {
          "description": "Note: \"myboard.mk\" for MSDK, \"myboard.yaml\" for Zephyr."
        },
        "boardName": {
          "title": "Board Name",
          "description": "The 'BOARD' string to be passed to the build system."
        },
        "package": {
          "label": {
            "title": "Package"
          },
          "select": {
            "title": "Select Package"
          }
        }
      }
    },
    "firmware": {
      "label": {
        "title": "Firmware Platform"
      },
      "select": {
        "title": "Select Firmware Platform"
      }
    },
    "template": {
      "heading": {
        "template": {
          "title": "Template"
        },
        "description": {
          "title": "Description"
        }
      },
      "label": {
        "title": "Template"
      },
      "placeholder": {
        "title": "Search Templates"
      }
    },
    "location": {
      "label": {
        "title": "Project Location"
      },
      "default": {
        "title": "Use default location"
      }
    }
  },
  "homepage": {
    "header": {
      "title": "CFS Homepage"
    },
    "title": {
      "welcome": {
        "title": "CodeFusion Studio"
      },
      "showAtStartup": {
        "title": "Show at startup"
      }
    },
    "help": {
      "title": "Welcome to CodeFusion Studio",
      "description": "<p>Use the <strong>Quick Access</strong> panel to create or open a workspace, or to load configuration and ELF files </p> <p>To get started with your environment setup, check out the <strong>Walkthrough</strong></p><p>Explore the <strong>Helpful Resources</strong> carousel for technical articles and videos, or find platform-specific datasheets, user guides, and documentation links under <strong>Documentation Related to Your Projects</strong></p><p>Need more? Click <strong>View more online documentation</strong> to browse the full knowledge base</p>"
    },
    "onlineHelp": {
      "title": "Online Help"
    },
    "engineerZone": {
      "title": "Engineer Zone"
    },
    "github": {
      "title": "GitHub"
    },
    "techSupport": {
      "title": "Tech Support"
    },
    "quickAccess": {
      "title": "Quick Access",
      "newWorkspace": {
        "title": "New Workspace"
      },
      "openWorkspace": {
        "title": "Open Workspace"
      },
      "openConfigFile": {
        "title": "Open Config File"
      },
      "openElfFile": {
        "title": "Open ELF File"
      }
    },
    "walkthrough": {
      "title": "Walkthrough",
      "getStarted": {
        "title": "Get started with the CodeFusion Studio VS Code extension"
      },
      "setup": {
        "title": "Set up your environment and create your first project."
      }
    },
    "carousel": {
      "title": "Helpful Resources"
    },
    "documentation": {
      "title": "Documentation Related to Your Projects",
      "seeMore": {
        "title": "View more online documentation"
      }
    }
  },
  "wrksp": {
    "soc-selection": {
      "description": "<p>Select the System on Chip (SoC) for your workspace from the list. Use the search bar to quickly find a specific SoC by name.",
      "help": {
        "title": "Select an SoC"
      }
    },
    "board-selection": {
      "description": "<p>Choose the appropriate board and package configuration for your SoC. <ul> <li><strong>Standard Boards and Packages:</strong> Ideal for quick setup and rapid prototyping, these are pre-configured boards suitable for a variety of applications. Click the documentation link for more information about each board.</li> <li><strong>Custom Board Packages:</strong> Select this option if you are working with a custom board. Note that fewer templates are available for custom board packages.</li></ul></p>",
      "help": {
        "title": "Select a Board and Package"
      }
    },
    "cores-selection": {
      "description": "<p>Select the cores for your workspace. Start with the primary core, which must be configured before you can continue. You can then add and configure additional cores as needed.<ol><li><strong>Select a core:</strong> Check the box next to the core you want to configure, starting with the primary core.</li><li><strong>Configure the core:</strong> With the core selected, click <strong>Config Options</strong> (to the right of the configuration status) to open the <strong>Core Configuration</strong> page.</li><li><strong>Apply configuration:</strong> On the configuration page, set options such as the firmware platform. Click <strong>Apply</strong> to save settings and return to the page.</li><li><strong>Review configuration:</strong> After applying settings, you can expand the configured core to review details before proceeding.</li></ol>Repeat these steps for any other cores you wish to configure.</p>",
      "help": {
        "title": "Select Cores for your Workspace"
      }
    },
    "core-config": {
      "description": "<p>Select a firmware platform and configure its options for your core. <ol><li><strong>Select a platform:</strong> Browse or use filters to select a specific firmware platform.</li><li><strong>Configure platform options:</strong> Set up the available options. These options vary depending on the selected platform.</li> <li><strong>Apply configuration:</strong> Click <strong>Apply</strong> to save your settings and return to the previous page.</li> </ol></p>",
      "help": {
        "title": "Configure the Core"
      }
    },
    "path-selection": {
      "description": "<p>Review your workspace settings, and choose a workspace name and location. <ul> <li><strong>Summary:</strong> Check the summary of your selected options, including SoC, board and package, and template details. You can go back to earlier steps to make changes if needed.</li> <li><strong>Workspace name: </strong> Enter a name for your workspace (required).</li><li><strong>Workspace location: </strong> Use the default location or uncheck the box and click <strong>Browse</strong> to select a different location.</li></ul></p>",
      "help": {
        "title": "Review and Create your Workspace"
      }
    },
    "template-selection": {
      "description": "<p>Browse available templates for your selected SoC. Use the search bar or filter options to find templates suited to specific firmware platforms, such as MSDK or Zephyr.</p>",
      "help": {
        "title": "Browse Templates"
      }
    },
    "workspace-options": {
      "description": "<p>Choose a workspace creation option. <ul> <li><strong>Select a workspace template:</strong> Choose from SoC predefined templates that come pre-populated with ADI recommended configurations. These templates provide a quick start with settings optimized for your SoC.</li> <li><strong>Manually configure the workspace:</strong> Continue setting up your system configuration manually for full control over every detail.</li></ul></p>",
      "help": {
        "title": "Choose a Workspace Creation Option"
      }
    }
  }
}
