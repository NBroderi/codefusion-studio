{"version":3,"file":"cfs-fs-copy-files-service.cjs","sources":["../../../../common/utilities/cfs-utilities.ts","../../../../common/services/cfs-fs-copy-files-service.ts"],"sourcesContent":["/**\n *\n * Copyright (c) 2025 Analog Devices, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/**\n * Evaluates a template string with nested template literals\n * @param template - The template string to evaluate\n * @param context - The context to evaluate the template literal from\n * @returns a function to evaluate the template string\n */\nexport function evalNestedTemplateLiterals(\n  template: string,\n  context: any,\n): string {\n  return new Function(\"context\", `return \\`${template}\\`;`)(context);\n}\n\n/**\n * Converts a string to title case\n * @param str - The string to convert to title case\n * @returns The string in title case\n */\nexport function titleCase(str: string) {\n  return str\n    .toLowerCase()\n    .split(\" \")\n    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))\n    .join(\" \");\n}\n","/**\n *\n * Copyright (c) 2025 Analog Devices, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as fs from \"fs/promises\";\nimport * as path from \"path\";\nimport { CfsFileMap } from \"cfs-plugins-api\";\nimport { CfsCopyFilesService } from \"./cfs-plugin-services.js\";\nimport { glob } from \"glob\";\nimport { evalNestedTemplateLiterals } from \"../utilities/cfs-utilities.js\";\n\n/**\n * Copies the provided files to the specified destination.\n *\n * @param files - An array of CfsFileMap objects representing the files to be copied.\n * @returns A promise that resolves when the files have been copied.\n */\nexport class CfsFsCopyFilesService implements CfsCopyFilesService {\n  /**\n   * Constructor\n   * @param pluginPath - The path to the plugin.\n   * @param context - The context containing workspace information.\n   */\n  constructor(\n    protected pluginPath: string,\n    protected context: Record<string, unknown>,\n  ) {}\n\n  async copyFiles(files: CfsFileMap[], baseDir?: string): Promise<void> {\n    for (const file of files) {\n      try {\n        // Probably deriving this from the context is not the most reliable way to get the location\n        // unless all configuration files share the same interface. the client of this service usually knows where files should go to.\n        const location = (baseDir ?? this.context.path ?? \"\") as string;\n\n        const dstPath = evalNestedTemplateLiterals(\n          path.join(location, file.dst).replace(/\\\\/g, \"/\"),\n          this.context,\n        );\n        const fullPath = path\n          .join(this.pluginPath, file.src)\n          .replace(/\\\\/g, \"/\");\n\n        const filesToCopy = await glob(fullPath);\n\n        for (const fileToCopy of filesToCopy) {\n          const fileName = path.basename(fileToCopy);\n\n          const isFile = path.extname(dstPath) !== \"\";\n\n          if (isFile) {\n            await fs.mkdir(path.dirname(dstPath), { recursive: true });\n            await fs.copyFile(fileToCopy, dstPath);\n          } else {\n            await fs.mkdir(dstPath, { recursive: true });\n            await fs.copyFile(fileToCopy, path.join(dstPath, fileName));\n          }\n        }\n      } catch (error) {\n        throw new Error(\n          `Failed to copy file from ${file.src} to ${file.dst}: ${error}`,\n        );\n      }\n    }\n  }\n}\n"],"names":["path","glob","fs"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;AAaG;AAEH;;;;;AAKG;AACa,SAAA,0BAA0B,CACxC,QAAgB,EAChB,OAAY,EAAA;AAEZ,IAAA,OAAO,IAAI,QAAQ,CAAC,SAAS,EAAE,CAAA,SAAA,EAAY,QAAQ,CAAA,GAAA,CAAK,CAAC,CAAC,OAAO,CAAC;AACpE;;AC1BA;;;;;;;;;;;;;AAaG;AASH;;;;;AAKG;MACU,qBAAqB,CAAA;AAOpB,IAAA,UAAA;AACA,IAAA,OAAA;AAPZ;;;;AAIG;IACH,WACY,CAAA,UAAkB,EAClB,OAAgC,EAAA;QADhC,IAAU,CAAA,UAAA,GAAV,UAAU;QACV,IAAO,CAAA,OAAA,GAAP,OAAO;;AAGnB,IAAA,MAAM,SAAS,CAAC,KAAmB,EAAE,OAAgB,EAAA;AACnD,QAAA,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;AACxB,YAAA,IAAI;;;AAGF,gBAAA,MAAM,QAAQ,IAAI,OAAO,IAAI,IAAI,CAAC,OAAO,CAAC,IAAI,IAAI,EAAE,CAAW;gBAE/D,MAAM,OAAO,GAAG,0BAA0B,CACxCA,eAAI,CAAC,IAAI,CAAC,QAAQ,EAAE,IAAI,CAAC,GAAG,CAAC,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,EACjD,IAAI,CAAC,OAAO,CACb;gBACD,MAAM,QAAQ,GAAGA;qBACd,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,GAAG;AAC9B,qBAAA,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC;AAEtB,gBAAA,MAAM,WAAW,GAAG,MAAMC,SAAI,CAAC,QAAQ,CAAC;AAExC,gBAAA,KAAK,MAAM,UAAU,IAAI,WAAW,EAAE;oBACpC,MAAM,QAAQ,GAAGD,eAAI,CAAC,QAAQ,CAAC,UAAU,CAAC;oBAE1C,MAAM,MAAM,GAAGA,eAAI,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,EAAE;oBAE3C,IAAI,MAAM,EAAE;AACV,wBAAA,MAAME,aAAE,CAAC,KAAK,CAACF,eAAI,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC;wBAC1D,MAAME,aAAE,CAAC,QAAQ,CAAC,UAAU,EAAE,OAAO,CAAC;;yBACjC;AACL,wBAAA,MAAMA,aAAE,CAAC,KAAK,CAAC,OAAO,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC;AAC5C,wBAAA,MAAMA,aAAE,CAAC,QAAQ,CAAC,UAAU,EAAEF,eAAI,CAAC,IAAI,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;;;;YAG/D,OAAO,KAAK,EAAE;AACd,gBAAA,MAAM,IAAI,KAAK,CACb,CAAA,yBAAA,EAA4B,IAAI,CAAC,GAAG,CAAO,IAAA,EAAA,IAAI,CAAC,GAAG,CAAA,EAAA,EAAK,KAAK,CAAA,CAAE,CAChE;;;;AAIR;;;;"}