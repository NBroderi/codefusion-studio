/**
 *
 * Copyright (c) 2024 Analog Devices, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
import {Command, Flags} from '@oclif/core';
import {CfsConfig, CfsSocDataModel} from 'cfs-plugins-api';
import {promises as fsp} from 'node:fs';

import {getSoc} from '../lib/socs.js';
import {getPluginManager} from '../utils/plugin-manager.js';

export default class PinconfigGenerate extends Command {
  static description =
    'Generate source code from the provided .cfsconfig file.';

  static flags = {
    input: Flags.file({
      char: 'i',
      required: true,
      summary: 'Set the .cfsconfig file.'
    }),
    output: Flags.directory({
      char: 'o',
      default: '.',
      summary: 'Set the output directory for generated code.'
    }),
    verbose: Flags.boolean({
      char: 'v',
      summary: 'Display full paths for generated code.'
    }),
    preview: Flags.boolean({
      char: 'p',
      summary: 'Display generated code on stdout.',
      hidden: true
    }),
    format: Flags.string({
      char: 'f',
      default: 'text',
      summary: 'Set the output format for preview.',
      options: ['text', 'json'],
      hidden: true
    }),
    force: Flags.boolean({
      default: false,
      summary: 'Forces file overwrites and folder creation.',
      hidden: true
    }),
    list: Flags.boolean({
      default: false,
      summary:
        'List the filenames that will be generated by the generate command.',
      hidden: true
    }),
    file: Flags.string({
      summary: 'Generate only the specified file.',
      hidden: true
    }),
    'search-path': Flags.string({
      char: 's',
      summary:
        'Specify additional search path. Can be used multiple times.',
      multiple: true // Allows multiple values
    })
  };

  async run() {
    const {flags} = await this.parse(PinconfigGenerate);
    const pluginManager = getPluginManager(flags['search-path']);

    // read input file
    const inputJson = await fsp
      .readFile(flags.input, 'utf8')
      .catch((error) => {
        throw new Error(
          `Could not read input file "${flags.input}".\n${error}`
        );
      });

    // parse input file
    let input;
    try {
      input = JSON.parse(inputJson);
    } catch (error) {
      throw new Error(
        `Could not parse input file "${flags.input}", maybe not json?\n${error}`
      );
    }

    const configdata = input as unknown as CfsConfig;

    // ensure there are no pin conflicts
    const isPinUsed = {} as Record<string, boolean>;
    for (const pin of configdata.Pins) {
      if (isPinUsed[pin.Pin]) {
        this.error(
          `This configuration contains a conflict for pin ${pin.Pin}.`
        );
      }

      isPinUsed[pin.Pin] = true;
    }

    const soc = (await getSoc(
      this.config,
      configdata.Soc.toLowerCase() +
        '-' +
        configdata.Package.toLowerCase()
    )) as unknown as CfsSocDataModel;

    let generatedFiles;

    try {
      generatedFiles = await pluginManager.generateConfigCode(
        {
          cfsconfig: configdata,
          datamodel: soc
        },
        flags.output
      );
    } catch (error) {
      throw new Error(`Failed to generate the files.\n${error}`);
    }

    if (!generatedFiles) {
      this.error(`No files were generated.`);
    }

    if (flags.verbose && Array.isArray(generatedFiles)) {
      for (const file of generatedFiles) {
        console.log(file);
      }
    }
  }
}
